\pdfoutput=1

\documentclass{l4proj}
\usepackage{url}
\usepackage{breakurl}
\usepackage[breaklinks]{hyperref}
\def\UrlBreaks{\do\/\do-}
\usepackage[T1]{fontenc}
\usepackage{float}

\begin{document}
\title{Automatically determining next semantic version of a project by \\
  inspecting changes to the codebase}
\author{Christian Shtarkov}
\date{\today}
\maketitle

\begin{abstract}
In software development, assigning a version number
to each release is crucial. It allows customers and other developers
to identify that a software package has changed from a previous
iteration. It is especially important when considering libraries and
frameworks, where changes can greatly affect applications built on top
of them. \\ Different policies exist dictating how to assign version
numbers, one of the most popular being \textit{Semantic
Versioning}\cite{SemanticVersioning}, where the version gives
information about how exactly the software package has changed. This
allows for better estimation whether a new version of a library or a
framework would result in incompatibilities.
\\\\
Regardless of
policy, assigning version numbers is typically done manually and
leaves room for human mistakes or deviations from the established
scheme. We propose the tool \textit{autobump} that automatically
inspects changes to a codebase and proposes the next version number
according to semantic versioning. This reduces friction when releasing
packages, and encourages more frequent, even fully automated,
releases.
\end{abstract}

\educationalconsent

\tableofcontents

%% Contents
\chapter{Introduction}
\pagenumbering{arabic}

\section{Semantic versioning}

There are different policies that dictate how versions of software
projects change with new releases. Popular ones include:

\begin{itemize}
\item Using the revision control number - typically only used
internally and can change multiple times per day. This can be a single
number increasing incrementally, such as the revision in Subversion,
or a hash like in Git.
\item Code names - most frequent in consumer-facing software, such as
\textit{macOS Sierra}. Code names are usually picked for marketing
purposes, rather than telling users something meaningful about the
software itself. Software that is released under a code name usually
also has an additional, sometimes non-public version number following
another scheme.
\item Semantic versioning (Semver)\cite{SemanticVersioning}. A widely
used scheme for decades, it was formalised by GitHub founder Tom
Preston-Werner who encourages all projects hosted there to follow it.
A majority of software projects, especially libraries, either outright
follow Semver or they closely approximate it. It is the most useful
from a developer's point of view.
\end{itemize}

Semver reveals information about how the software package has changed
from a previous iteration by dividing the version into three
independent numbers:
\begin{center}
\textbf{MAJOR.MINOR.PATCH}
\end{center}

\begin{itemize}
\item \textbf{MAJOR} increments when incompatible changes to the API
have been made.
\item \textbf{MINOR} increments when new features has been added in a
backwards-compatible manner.
\item \textbf{PATCH} increments when bugs were fixed in a
backwards-compatible manner.
\end{itemize}

\subsection{Benefits}

Semver is especially useful for software meant for use by other
software, such as libraries and frameworks. When a new version of a
library is released, someone developing an application based on that
library can quickly judge how the update affects their application.

If only the minor or patch numbers have changed, then the application
should work fine with the new version. That is because incrementing
just those numbers implies that there are no breaking changes. If,
however, the major number has increased, then further work on part of
the application developer may be needed to make it compatible again
with the library.

This scheme also helps with automatic dependency management systems,
like ones found in package managers. A developer can specify that
their application relies on version \textit{2.4} of a particular
library. Semver guarantees that versions of the form \textit{(2.x | x
> 4)} will contain all features found in \textit{2.4} and be
backwards-compatible. If later on \textit{2.4.1} or \textit{2.5} come
along, the library can be automatically upgraded without breaking the
application, with the added benefit of fixing bugs.

In summary, the most important benefit provided by Semver is the
alleviation of dependency hell through unambiguous identification of
breaking changes. The major version number is increased if and only if
backwards compatibility is deprecated.

\subsection{Application}

Semver only provides these benefits when it is applied consistently.
If applied haphazardly, then two versions cannot be compared
reliably and decisions made by simply examining version numbers are
risky. A good example of that is the programming language PHP.
Although minor releases are usually meant for feature additions, it
can happen that they contain breaking changes along with the new
features. One the many examples are the changes introduced in PHP 5.3
compared to PHP 5.2\cite{PHPChangelog} where the signature of an array
of functions changed - constituting a breaking change. The PHP
changelogs routinely document what backwards-incompatible changes are
in a release, but using the versioning scheme incosistently negates
most benefits.

In practice, semantic versioning is applied poorly. A
study\cite{SemverMaven} of more than 22,000 libraries in the Maven
repository found that there was virtually no difference in the
frequency of breaking changes in major and minor version increments.
It also found that this has a significant impact on client
applications, mostly by the introduction of compilation errors.

The study does not go into determining what the reasons are for these
inconsistencies, but some possibilities are:
\begin{itemize}
\item Some libraries never claimed to follow Semver, instead opting
for a similar, yet not identical, scheme.
\item Semver is very strict about what's considered a breaking change.
This is great for robots, but not so much for humans. Small changes to
the API may not be considered ``major'' by the developers even if they
are technically breaking.
\item Misinterpretation of Semver about what constitutes a breaking
change. Some developers may be inclined to believe that an API change
that affects none of their users (to their knowledge) is not breaking.
\end{itemize}

One possible solution to this problem, which we propose in this
project, is to attempt to automate the assignment of version numbers.

\section{Tools for automatically assigning semantic version numbers}

Automatically assigning version numbers is not a new idea and projects
exist that already do that to some extent.

\subsection{semantic-release}

\textit{semantic-release}\cite{SemanticRelease} is a Javascript tool
for ``fully automated package publishing''. It can do a range of
functions related to automated publishing of packages in the
Javascript ecosystem through the Node Package Manager, but of interest
are the two ways it can deal with proposing a new version number.

One way is that it tries to interpret Git commit messages and from
that determines what the next version number should be. A minor
(feature) release for example would be indicated by a commit message
of the following format:

\begin{center}
\texttt{feat(pencil): add 'graphiteWidth' option}
\end{center}

This approach suffers from the same drawback as incrementing the
version number manually does - it has to be done consistently.

Another way is by employing an additional tool called
\textit{cracks}\cite{Cracks}. According to the official description
``this module can automatically detect breaking changes by running the
test suite of your last-release against the current codebase. This
shouldn't fail''. This is generally a good approach - by definition
the test suite of the previous version should pass if the new one is
not meant to be a major release. However, it raises some issues.

\begin{itemize}
\item It could be that the library in question has whitebox unit
tests. If they start failing, that does not necessarily constitute a
breaking change, because while the internal implementation of those
methods may have changed, the public API is still the same. Cracks has
no way of differentiating blackbox from whitebox tests unless manually
specified.
\item The unit tests may not cover the public API in its entirety.
Modifying the signature of a public method, for example, that's not
covered by the tests may go completely unnoticed.
\item The library may be in a stage of development such that it has no
unit tests, or they cover a very small portion of the public API, yet
the authors still want to use semantic versioning.
\end{itemize}

\subsection{GitVersion}

\textit{GitVersion}\cite{GitVersion} ``looks at your Git history and
works out the semantic version of the commit being built''.  By
knowing in advance what workflow contributors to the repository are
using, it can determine when breaking changes occur, when new features
are being introduced and when it's only patches that are going
through. Previous versions of GitVersion have implicit knowledge of
the workflows \textit{GitFlow}\cite{GitFlow} and
\textit{GitHubFlow}\cite{GitHubFlow}, but the current one (3.0) at the
time of writing can be configured to work with more custom workflows.

Consider an example usage of GitVersion on a history of commits.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/dot/gitversionexample}
\caption{Example Git commit history}
\end{figure}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\textbf{Commit} & \textbf{Version} & \textbf{Explanation}                              \\
0      & 1.0.0                 & First commit that has a version.                      \\
1      & 1.0.1+1               & Patch was introduced, and one commit since then.      \\
2      & 1.0.1-feature-foo.1+1 & Feature was introduced, and one commit since then.    \\
3      & 1.0.1+3               & Three commits since the last patch.                   \\
4      & 1.1.0-rc.1            & First release candidate for the new feature.          \\
5      & 1.1.0                 & Feature branch was merged.                            \\
6      & 1.1.1+1               & Patch was introduced, and one commit since then.      \\
7      & 1.1.1+2               & Patch was introduced, and two commits since then.     \\
8      & 2.0.0-rc.1            & First release candidate for the new breaking changes. \\
9      & 2.0.0                 & Breaking release branch was merged.
\end{tabular}
\caption{Proposed semantic version numbers by GitVersion, if every
commit were to be released}
\end{table}

Notice that similarly to semantic-release, GitVersion relies on the
naming of the branches. This results in the same set of drawbacks. It
has to be applied consistently, and forces contributors to use one
particular naming scheme. The latter one is somewhat alleviated in
this case, as the workflow GitVersion expects is highly
configurable\cite{GitVersionConfiguration}.

\subsection{Endjin.Assembly.ChangeDetection}

\textit{Endjin.Assembly.ChangeDetection}\cite{Endjin} is a
proof-of-concept project that takes a very different and less
error-prone approach. It can identify breaking changes in .NET
assemblies by looking at the assembly itself. It does this
by examining any changes made to public types in the assembly, such as
removing them or changing their signature.

This way of proposing a version number truly reflects changes to
the code and imposes no additonal requirements on contributors to
the repository. However, Endjin.Assembly.ChangeDetection is not really
a tool, but an experiment, and is tied to the .NET ecosystem.

\section{Determining next semantic version through code analysis}

Much like Endjin.Assembly.ChangeDetection, the tool we propose tries
to look at how the code itself has changed to estimate what the next
version should be. This requires no manual intervention from the user,
no special naming schemes, and is as reliable as it can get.

% TODO: Determining vs Estimation?

\subsection{Breaking changes}

For the definition of breaking change to be useful, it ought to be
strict - and that is the way Semver approaches it. It defines
\textbf{any} change to the API which makes it incompatible with the
last version as breaking. It does not take into account number of
affected users or difficulty of transitioning to the new version,
because those things cannot be possibly known reliably.

In the spirit of Semver, for this project we adopted a technical and
deterministic list of changes to entities that are considered
to be breaking. We make the assumption that all public-facing entities
(i.e. those accessible externally in a normal for the language way)
are part of the API.

\begin{table}[H]
\centering
\begin{tabular}{|p{0.45\linewidth}|p{0.45\linewidth}|}
\hline
\textbf{Change}                                                                               & \textbf{Rationalisation}                                                 \\
\hline
Removing an entity.                                                                           & User applications may be using it.                                       \\
\hline
Changing the type of an entity to an incompatible type.                                       & User applications may be expecting a different type.                     \\
\hline
Adding a parameter with no default value to a function signature.                             & Calls to that function will immediately fail due to a missing parameter. \\
\hline
Removing a parameter from a function signature, regardless of whether it had a default value. & Calls to that function \textit{may} fail due to a missing parameter.     \\
\hline
Removing the default value of a parameter.                                                    & Calls to that function may be relying on the now missing default value.  \\
\hline
\end{tabular}
\caption{List of changes that are considered breaking}
\end{table}

\subsection{Feature additions}

In comparison to breaking changes, determining what constitutes a
feature addition seems to be trivial. Continuing with the assumption
that all publicly available types and functions are suitable for
external use, it is sufficient to claim that the addition of one or
several public entities or default values is a feature release.

\subsection{The \textit{autobump} tool}

The goal of this project was to build \textit{autobump} - a tool which
given two revisions in a version controlled project reliably
determines what the version of the later revision should
be\footnote{In some contexts, ``version'' and ``revision'' may be
identical. In this dissertation, we refer to the semantic version of a
release as ``version'', and the commit identifier in a VCS as ``revision''}.

Because identifying the version delta requires first identifying a
list of changes to the public API, a secondary function of autobump is
the generation of a changelog in preparation for a release.

The tool can be used standalone as a sanity check, or for its
changelog generation capabilities, or it can be integrated in a
deployment pipeline so that correct version numbers are automatically
assigned to releases with no human intervention.

Autobump, while its core is written in Python, is modular in
nature\ref{Architecture} and supports different
languages\ref{LanguageHandlers} and version control
systems\ref{VCSHandlers}.

\chapter{Implementation}

\section{List of features}

\label{Architecture}
\section{Architecture}

\begin{minipage}{0.5\textwidth}
When designing the architecture of the tool, great care was taken to
separate unrelated concerns. Every part of the program lives in a
separate file, with dependencies (via \texttt{import}) reduces to a minimum.

In normal operation, the top-level program generally performs the
following steps:

\begin{enumerate}
\item Identify which VCS the repository is using and select the
appropriate handler.
\item Identify which two revisions should be compared -- either from
command-line arguments or through an educated guess.
\item Run the comparison logic on the two revisions. This involves
converting the APIs of both into a common representation via the
appropriate language handler.
\item Calculate the new version number by bumping the old one.
\end{enumerate}

\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{images/dot/architecture}
\caption{\textit{autobump} architecture}
\end{figure}
\end{minipage}

\label{VCSHandlers}
\subsection{Handlers for version control systems}

\label{LanguageHandlers}
\subsection{Handlers for programming languages}

\subsubsection{Python}

% TODO: Introspection vs AST
% TODO: Dynamic typing, Structural types

\subsubsection{Java}

\subsection{Comparison logic}

\section{Application user interface}

\subsection{Integration with other development tools}

\chapter{Testing}

\section{Unit testing}

\section{Acceptance testing}

\chapter{Evaluation}

% TODO: Evaluation was continuous in nature

\section{Evaluation against real-world projects}

% TODO: Evaluate with students in lab as well?

\chapter{Conclusion}

\begin{appendices}

\chapter{Instructions for building and running \textit{autobump}}

Autobump requires at least Python 3.5. Other than that, it has no
dependencies. A typical Python setup involving a virtual environment
is not necessary.

\section{Building}

As it is written in Python, autobump does not have a build step. The
\texttt{Makefile} found in the repository has the following targets:

\begin{itemize}
\item \texttt{make test} runs the test suite.
\item \texttt{make lint} runs the linter \texttt{flake8} (or the one
specified as \texttt{LINTER}) against all source code.
\item \texttt{make all} or \texttt{make} runs all of the above.
\end{itemize}

\section{Usage}

\end{appendices}

%% Bibliography
\bibliographystyle{ieeetr}
\bibliography{dissertation}

\end{document}

% Local Variables:
% eval: (auto-fill-mode 1)
% sentence-end-double-space: nil
% End:
