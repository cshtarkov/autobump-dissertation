\pdfoutput=1

\documentclass{l4proj}
\usepackage{url}
\usepackage{breakurl}
\usepackage[breaklinks]{hyperref}
\def\UrlBreaks{\do\/\do-}
\usepackage[T1]{fontenc}
\usepackage{float}

\begin{document}
\title{Automatically determining next semantic version of a project by \\
  inspecting changes to the codebase}
\author{Christian Shtarkov}
\date{\today}
\maketitle

\begin{abstract}
In software development, assigning a version number
to each release is crucial. It allows customers and other developers
to identify that a software package has changed from a previous
iteration. It is especially important when considering libraries and
frameworks, where changes can greatly affect applications built on top
of them. \\ Different policies exist dictating how to assign version
numbers, one of the most popular being \textit{Semantic
Versioning}\cite{SemanticVersioning}, where the version gives
information about how exactly the software package has changed. This
allows for better estimation whether a new version of a library or a
framework would result in incompatibilities.
\\\\
Regardless of
policy, assigning version numbers is typically done manually and
leaves room for human mistakes or deviations from the established
scheme. We propose the tool \textit{autobump} that automatically
inspects changes to a codebase and proposes the next version number
according to semantic versioning. This reduces friction when releasing
packages, and encourages more frequent, even fully automated,
releases.
\end{abstract}

\educationalconsent

\tableofcontents

%% Contents
\chapter{Introduction}
\pagenumbering{arabic}

\section{Semantic versioning}

There are different policies that dictate how versions of software
projects change with new releases. Popular ones include:

\begin{itemize}
\item Using the revision control number - typically only used
internally and can change multiple times per day. This can be a single
number increasing incrementally, such as the revision in Subversion,
or a hash like in Git.
\item Code names - most frequent in consumer-facing software, such as
\textit{macOS Sierra}. Code names are usually picked for marketing
purposes, rather than telling users something meaningful about the
software itself. Software that is released under a code name usually
also has an additional, sometimes non-public version number following
another scheme.
\item Semantic versioning (Semver)\cite{SemanticVersioning}. It was
formalised by GitHub founder Tom Preston-Werner, who encourages all
projects hosted there to follow it. A majority of software projects,
especially libraries, either outright follow Semver or they closely
approximate it. It is the most useful from a developer's point of
view.
\end{itemize}

Semver reveals information about how the software package has changed
from a previous iteration by dividing the version into three
independent numbers:
\begin{center}
\textbf{MAJOR.MINOR.PATCH}
\end{center}

\begin{itemize}
\item \textbf{MAJOR} increments when incompatible changes to the API
have been made.
\item \textbf{MINOR} increments when new features has been added in a
backwards-compatible manner.
\item \textbf{PATCH} increments when bugs were fixed in a
backwards-compatible manner.
\end{itemize}

\subsection{Benefits}

Semver is especially useful for software meant for use by other
software, such as libraries and frameworks. When a new version of a
library is released, someone developing an application based on that
library can quickly judge how the update affects their application.

If only the minor or patch numbers have changed, then the application
should work fine with the new version. That is because incrementing
just those numbers implies that there are no breaking changes. If,
however, the major number has increased, then further work on part of
the application developer may be needed to make it compatible again
with the library.

This scheme also helps with automatic dependency management systems,
like ones found in package managers. A developer can specify that
their application relies on version \textit{2.4} of a particular
library. Semver guarantees that versions of the form \textit{(2.x | x
 > 4)} will contain all features found in \textit{2.4} and be backwards-compatible.
If later on \textit{2.4.1} or \textit{2.5} come along, the
library can be automatically upgraded without breaking the
application, with the added benefit of fixing bugs.

\subsection{Application}

Semver only provides these benefits when it is applied consistently.
If applied haphazardly, then two versions cannot be compared
reliably and decisions made by simply examining version numbers are
risky. A good example of that is the programming language PHP.
Although minor releases are usually meant for feature additions, it
can happen that they contain breaking changes along with the new
features. One the many examples are the changes introduced in PHP 5.3
compared to PHP 5.2\cite{PHPChangelog} where the signature of an array
of functions changed - constituting a breaking change. The PHP
changelogs routinely document what backwards-incompatible changes are
in a release, but using the versioning scheme incosistently negates
most benefits.

In practice, semantic versioning is applied poorly. A
study\cite{SemverMaven} of more than 22,000 libraries in the Maven
repository found that there was virtually no difference in the
frequency of breaking changes in major and minor version increments.
It also found that this has a significant impact on client
applications, mostly by the introduction of compilation errors.

One possible solution to this problem, which we propose in this
project, is to attempt to automate the assignment of version numbers.

\section{Tools for automatically assigning semantic version numbers}

Automatically assigning version numbers is not a new idea and projects
exist that already do that to some extent.

\subsection{semantic-release}

\textit{semantic-release}\cite{SemanticRelease} is a Javascript tool
for ``fully automated package publishing''. It can do a range of
functions related to automated publishing of packages in the
Javascript ecosystem through the Node Package Manager, but of interest
are the two ways it can deal with proposing a new version number.

One way is that it tries to interpret Git commit messages and from
that determines what the next version number should be. A minor
(feature) release for example would be indicated by a commit message
of the following format:

\begin{center}
\texttt{feat(pencil): add 'graphiteWidth' option}
\end{center}

This approach suffers from the same drawback as incrementing the
version number manually does - it has to be done consistently.

Another way is by employing an additional tool called
\textit{cracks}\cite{Cracks}. According to the official description
``this module can automatically detect breaking changes by running the
test suite of your last-release against the current codebase. This
shouldn't fail''. This is generally a good approach - by definition
the test suite of the previous version should pass if the new one is
not meant to be a major release. However, it raises some issues.

\begin{itemize}
\item It could be that the library in question has whitebox unit
tests. If they start failing, that does not necessarily constitute a
breaking change, because while the internal implementation of those
methods may have changed, the public API is still the same. Cracks has
no way of differentiating blackbox from whitebox tests unless manually
specified.
\item The unit tests may not cover the public API in its entirety.
Modifying the signature of a public method, for example, that's not
covered by the tests may go completely unnoticed.
\item The library may be in a stage of development such that it has no
unit tests, or they cover a very small portion of the public API, yet
the authors still want to use semantic versioning.
\end{itemize}

\subsection{GitVersion}

\textit{GitVersion}\cite{GitVersion} ``looks at your Git history and
works out the semantic version of the commit being built''.  By
knowing in advance what workflow contributors to the repository are
using, it can determine when breaking changes occur, when new features
are being introduced and when it's only patches that are going
through. Previous versions of GitVersion have implicit knowledge of
the workflows \textit{GitFlow}\cite{GitFlow} and
\textit{GitHubFlow}\cite{GitHubFlow}, but the current one (3.0) at the
time of writing can be configured to work with more custom workflows.

Consider an example usage of GitVersion on a history of commits.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/dot/gitversionexample}
\caption{Example Git commit history}
\end{figure}

\begin{table}[H]
\centering
\label{my-label}
\begin{tabular}{|l|l|l|}
\textbf{Commit} & \textbf{Version} & \textbf{Explanation}                              \\
0      & 1.0.0                 & First commit that has a version.                      \\
1      & 1.0.1+1               & Patch was introduced, and one commit since then.      \\
2      & 1.0.1-feature-foo.1+1 & Feature was introduced, and one commit since then.    \\
3      & 1.0.1+3               & Three commits since the last patch.                   \\
4      & 1.1.0-rc.1            & First release candidate for the new feature.          \\
5      & 1.1.0                 & Feature branch was merged.                            \\
6      & 1.1.1+1               & Patch was introduced, and one commit since then.      \\
7      & 1.1.1+2               & Patch was introduced, and two commits since then.     \\
8      & 2.0.0-rc.1            & First release candidate for the new breaking changes. \\
9      & 2.0.0                 & Breaking release branch was merged.
\end{tabular}
\caption{Proposed semantic version numbers by GitVersion, if every
commit were to be released}
\end{table}

Notice that similarly to semantic-release, GitVersion relies on the
naming of the branches. This results in the same set of drawbacks. It
has to be applied consistently, and forces contributors to use one
particular naming scheme. The latter one is somewhat alleviated in
this case, as the workflow GitVersion expects is highly
configurable\cite{GitVersionConfiguration}.

\subsection{Endjin.Assembly.ChangeDetection}

\textit{Endjin.Assembly.ChangeDetection}\cite{Endjin} is a
proof-of-concept project that takes a very different and less
error-prone approach. It can identify breaking changes in .NET
assemblies by looking at the assembly itself. It does this
by examining any changes made to public types in the assembly, such as
removing them or changing their signature.

This way of proposing a version number truly reflects changes to
the code and imposes no additonal requirements on contributors to
the repository. However, Endjin.Assembly.ChangeDetection is not really
a tool, but an experiment, and is tied to the .NET ecosystem.

\section{Determining next semantic version through code analysis}

Much like Endjin.Assembly.ChangeDetection, the tool we propose tries
to look at how the code itself has changed to estimate what the next
version should be. This requires no manual intervention from the user,
no special naming schemes, and is as reliable as it can get.

% TODO: Determining vs Estimation?

\subsection{Breaking changes}

% TODO: What's a breaking change?

\subsection{Feature additions}

% TODO: What's a feature release?

In comparison to breaking changes, determining what constitutes a
feature addition seems to be trivial. Continuing with the assumption
that all publicly available types and functions are suitable for
external use, it is sufficient to claim that the addition of one or
several public types or functions is a feature release.

\subsection{The \textit{autobump} tool}

% TODO: Rewrite this.

\textit{autobump} can compare two commits in a version controlled
project and if the version number of the earlier commit is known, it can determine
what the version number of the later commit should be. It adheres to the formal
rules specified by Semver\cite{SemanticVersioning} and detects breaking changes,
added features and bugfixes.

%% TODO: A paragraph on language support.

The tool can be used standalone as a sanity check for the developer, or integrated
as part of a continuous deployment mechanism so that correct version numbers are
automatically assigned to releases. Using it instead of assigning versions manually
also leaves less room for human errors, such as presumably the one that caused PHP
to have different behaviour in two consecutive patch releases.

%% TODO: Also generate changelogs?

%% Bibliography
\bibliographystyle{ieeetr}
\bibliography{dissertation}

\end{document}

% Local Variables:
% eval: (auto-fill-mode 1)
% sentence-end-double-space: nil
% End:
